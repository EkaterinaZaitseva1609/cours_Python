# Создаем, записываем и читаем данные из файла (все данные хранятся в текстовом виде, если нужно работать с данными, как с числами,
# необходимо произвести конвертацию int

# colors = ['red', 'green', 'yellow']
# data = open('file.txt', 'a') #модификатор 'a' создает новый файл и записывает в него (либо дописывает, не удаляя); 'w' = перезаписывает данные в файл
# # data.writelines(colors)
# data.write('\n LINE 2 \n') #дописываем данные
# data.write('LINE 3 \n')
# data.close()

# другой вариант записи данных
# with open('file.txt', 'w') as date:
#     date.write('Line 3 \n')
#     date.write('Line 4 \n')

# path = 'file.txt' # указали путь к файлу
# data = open(path, 'r') #режим чтения
# for line in data: #создаем цикл, пробегаем по нему
#     print(line) # печатаем данные
# data.close() #закрываем, чтобы избужать утечки памяти
# exit()

# Функции и модули (функция - это фрагмент программы, используемый многократно)

# отсылаем к файлу с функцией, чтобы в этом файле ее вызвать
# import function
# print(function.p(1))

# если не хочется все аремя писать долгое название файла, где лежит функция, ему можно дать псевдоним function = f (например)
# import function as f
# print(f.p(1))

# Значения по умолчанию для функции
# def new_string (symbol, count):
#     return symbol * count
# print(new_string('!', 5)) #!!!!! (в пайтон мы можем складывать \ умножать строку с числами

# def new_string(symbol, count=3): #второй аргумент передан сразу
#     return symbol * count
# print(new_string('!')) # !!! (поэтому тут можно указать тот аргумент, который сразу был не указан)
# print(new_string(4))  # 12 (пайтон распознает тип данных в момент вызова функции, если в качестве аргумента передать число, то число будет умножено на 3(заданный аргумент))

# Возможность передать любое кол-во аргументов в функции
# def concatinatio(*params):
#     res: str = "" #тут явно прописан тип данных, если нужно работать с цифрами, то вместо str пишу res: int = 0 (произойдет сложение чисел). указание типа данных не обязательно
#     for item in params:
#         res += item
#     return res

# print(concatinatio('a', 'b', 'c', 'd')) #abcd
# print(concatinatio('a', '1')) # a1
# print(concatinatio(2, 3, 4)) #Error так как логика метода завязана на строках

# РЕКУРСИЯ
# def fib (n):
#     if n in [1, 2]:
#         return 1
#     else:
#         return fib(n-1) + fib(n-2)
#
# list = []
# for e in range (1, 10):
#     list.append(fib(e))
# print(list) #[1, 1, 2, 3, 5, 8, 13, 21, 34]

# КОРТЕЖИ ( некий неизменяемый список, может состоять из большого списка координат )
# (a) = (3, 4)
# print(a)
# print(a[0])
# присвоение элементов как в списке, в кортежах не работает, не зра его называют = неизменяемый список
# a = (3) такая запись не является кортежем, необходимо поставить запятую, даже если кортеж состоит из одного элемента a = (3,)

# кортежи можно перебирать при помощи циклоа for
# a = (3, 4, 5)
# for item in a:
#     print(item)

# в рамках одного кортежа можно использовать разные типы данных
# кортеж можно распаковать в отдельные переменные, например:
# t = tuple(['red', 'green', 'blue']) # в данном случае создается список и конвертируется в кортеж (двойное прелобразование)
# red, green, blue = t  #распаковываем кортеж и превращаем в переменные
# print('r: {} g: {} b:{}' .format(red, green, blue)) #далее работаем как с отдельными переменными.  В консоль:r: red g: green b:blue

# СЛОВАРИ
# неупорядоченные коллекции произвольных объектов с доступом по ключу
# dictionari = {} #пустой словарь
dictionari = \
    {
        'up': '^',
        'left': '<',
        'right': '>'
    }
# print(dictionari) #ключ указывается слева, например up - это ключ, а '^' - это его значение
# print(dictionari['left']) #обращение к элементу списка по ключу

# for k in dictionari.keys(): #если хотим посмотреть ключи в данном словаре
#     print(k)
# for k in dictionari.values(): #если хотим посмотреть значения
#     print(k)

# МНОЖЕСТВА (базовые функции) - в множествах только уникальные элементы
# colors = {'red', 'blue', 'yellow'}
# print(colors)
# #у множества можно добавлять значения
# # colors.add('blue') #если добавляемое значение повторяется с существующим в множестве, оно не добавится
# colors.add('green') #новое значение добавлено
# print(colors)
# colors.remove('red') #значение red удалено
# print(colors)
# # colors.clear() # очистить множество и начать работать с множеством с чистого листа
# # print(colors)
# c = colors.copy() #скопировать множество
# print(c)
# u = c.union(c) #объединение множеств
# print(u)

# можно работать с изменяемым множеством, а можено сделать его неизменяемым (заморозить - frozenset)
# s = frozenset(a)

# СПИСКИ (БОЛЕЕ УГЛУБЛЕННАЯ РАБОТА)

#скопированный список меняет элементы также, как и тот, с кого он скопирован
# list1 = [1, 2, 3, 4, 5]
# list2 = list1 #делаем копию
# for e in list1:
#     print(e)
# print()
# for e in list2:
#     print(e)
#
# list1[0] = 123
# list1[1] = 16
#
# for e in list1:
#     print(e)
# print()
# for e in list2:
#     print(e)

# как удалить элементы списка
list1 = [1, 2, 3, 4, 5]
# print(list1.pop()) #удаляет последний элемент списка
# print(len(list1))
# print(list1.pop(2)) # аргумент 2 показывает (по индексу), какой именно элемент нужно удалить

# как добавить эдемент в список
print(list1.insert(2, 11)) # добавить элемент 11 на позицию 2 (по индексу)
print(list1)
print(list1.append(11)) # добавить элемент 11 в конец списка
print(list1)